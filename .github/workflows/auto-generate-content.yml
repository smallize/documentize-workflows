name: auto-generate-content

on:
  workflow_dispatch:

jobs:
  generate_content:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout theme repo
      uses: actions/checkout@v4
      with:
        repository: smallize/documentize
        token: ${{ secrets.REPO_TOKEN }}
        fetch-depth: 0 
        submodules: true

    - name: Install Required Tools
      run: |
        sudo apt-get update
        sudo apt-get install -y jq

    - name: Detect Newly Added Files
      id: detect_changes
      run: |
        # Fetch all history so we can compare commits
        git fetch --prune --unshallow

        # Get the list of added files in the push
        git log --format="" --name-status ${{ github.event.before }}..${{ github.event.after }} \
          | grep '^A' | awk '{print $2}' | sort | uniq > added_files.txt

        echo "Added files detected:"
        cat added_files.txt

    - name: Check for Added Files
      run: |
        if [ ! -s added_files.txt ]; then
          echo "No added files detected. Exiting."
          exit 0
        fi

    - name: Collect File Contents
      id: collect_files
      run: |
        CONTENT=""
        while IFS= read -r file; do
          if [ -f "$file" ]; then
            FILE_CONTENT=$(cat "$file")
            CONTENT="${CONTENT}\n\n--- FILE: ${file} ---\n\n${FILE_CONTENT}"
          else
            echo "File $file not found"
          fi
        done < added_files.txt

        # Write the collected content to a file
        echo -e "${CONTENT}" > collected_content.txt

    - name: Provide Existing Features to AI
      id: provide_existing_features
      run: |
        # Initialize variable
        EXISTING_FEATURES=""

        # Check if the products directory exists
        if [ -d "content/products.documentize.com/en/" ]; then
          # Gather existing feature names from the products section
          FEATURES_PRODUCTS=$(find content/products.documentize.com/en/ -mindepth 1 -maxdepth 1 -type d -exec basename {} \;)
          EXISTING_FEATURES="$EXISTING_FEATURES $FEATURES_PRODUCTS"
        fi

        # Check if the docs directory exists
        if [ -d "content/docs.documentize.com/en/developers-guide/" ]; then
          # Gather existing feature names from the docs section
          FEATURES_DOCS=$(find content/docs.documentize.com/en/developers-guide/ -mindepth 1 -maxdepth 1 -type d -exec basename {} \;)
          EXISTING_FEATURES="$EXISTING_FEATURES $FEATURES_DOCS"
        fi

        echo "Existing feature names: $EXISTING_FEATURES"

        # Write existing features to a file
        echo "${EXISTING_FEATURES}" > existing_features.txt

    - name: Generate Feature Name via AI
      id: generate_feature_name
      run: |
        COLLECTED_CONTENT=$(cat collected_content.txt)
        EXISTING_FEATURES=$(cat existing_features.txt)

        # Prepare JSON data
        JSON_DATA=$(jq -n \
          --arg model "gpt-4o-mini" \
          --arg prompt "Given the following file content:\n\n$COLLECTED_CONTENT\n\nAnd the existing features:\n$EXISTING_FEATURES\n\nSuggest a concise, descriptive feature name for the newly added functionality:" \
          --arg max_tokens "50" \
          '{model: $model, prompt: $prompt, max_tokens: ($max_tokens|tonumber)}')

        # Make API call
        AI_RESPONSE=$(curl -s -X POST https://api.openai.com/v1/completions \
          -H "Authorization: Bearer ${{ secrets.OPENAI_API_KEY }}" \
          -H "Content-Type: application/json" \
          -d "$JSON_DATA")

        # Extract feature name and sanitize it
        FEATURE_NAME=$(echo "$AI_RESPONSE" | jq -r '.choices[0].text' | tr -d '\n' | sed 's/[^a-zA-Z0-9_-]//g')
        echo "Generated feature name: $FEATURE_NAME"

        # Write the feature name to a file
        echo "$FEATURE_NAME" > feature_name.txt

    - name: Generate Consolidated Content
      id: generate_content
      run: |
        COLLECTED_CONTENT=$(cat collected_content.txt)
        FEATURE_NAME=$(cat feature_name.txt)

        # Ensure templates exist
        mkdir -p content/releases.documentize.com/en/releases-notes/
        mkdir -p content/products.documentize.com/en/html-converter/
        mkdir -p content/docs.documentize.com/en/developers-guide/sample-guide/

        TEMPLATE_RELEASE=$(cat content/releases.documentize.com/en/releases-notes/24.8.md)
        TEMPLATE_PRODUCT=$(cat content/products.documentize.com/en/html-converter/_index.md)
        TEMPLATE_DOC=$(cat content/docs.documentize.com/en/developers-guide/sample-guide/_index.md)

        # Prepare JSON data
        JSON_DATA=$(jq -n \
          --arg model "gpt-4o-mini" \
          --arg prompt "Analyze the following file content:\n\n$COLLECTED_CONTENT\n\nBased on the suggested feature name \"$FEATURE_NAME\", generate:\n1. A release note using this template:\n$TEMPLATE_RELEASE\n2. A product page using this template:\n$TEMPLATE_PRODUCT\n3. A documentation page using this template:\n$TEMPLATE_DOC" \
          --arg max_tokens "2048" \
          '{model: $model, prompt: $prompt, max_tokens: ($max_tokens|tonumber)}')

        # Make API call
        RESPONSE=$(curl -s -X POST https://api.openai.com/v1/completions \
          -H "Authorization: Bearer ${{ secrets.OPENAI_API_KEY }}" \
          -H "Content-Type: application/json" \
          -d "$JSON_DATA")

        # Extract sections from the API response
        FULL_TEXT=$(echo "$RESPONSE" | jq -r '.choices[0].text')

        # Check if the response contains expected sections
        if [[ "$FULL_TEXT" == *"Release Notes:"* ]] && [[ "$FULL_TEXT" == *"Product Page:"* ]] && [[ "$FULL_TEXT" == *"Documentation Page:"* ]]; then
          RELEASE_NOTES=$(echo "$FULL_TEXT" | sed -n '/Release Notes:/,/Product Page:/p' | sed '/Product Page:/d')
          PRODUCT_PAGE=$(echo "$FULL_TEXT" | sed -n '/Product Page:/,/Documentation Page:/p' | sed '/Documentation Page:/d')
          DOC_PAGE=$(echo "$FULL_TEXT" | sed -n '/Documentation Page:/,$p')
        else
          echo "API response does not contain expected sections. Exiting."
          exit 1
        fi

        # Write outputs to respective files
        mkdir -p content/releases.documentize.com/en/releases-notes/
        echo "$RELEASE_NOTES" > content/releases.documentize.com/en/releases-notes/24.11.md

        mkdir -p content/products.documentize.com/en/$FEATURE_NAME/
        echo "$PRODUCT_PAGE" > content/products.documentize.com/en/$FEATURE_NAME/_index.md

        mkdir -p content/docs.documentize.com/en/developers-guide/$FEATURE_NAME/
        echo "$DOC_PAGE" > content/docs.documentize.com/en/developers-guide/$FEATURE_NAME/_index.md

    - name: Commit Consolidated Content
      run: |
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        # Add new files
        git add content/releases.documentize.com/en/releases-notes/24.11.md
        git add content/products.documentize.com/en/$FEATURE_NAME/_index.md
        git add content/docs.documentize.com/en/developers-guide/$FEATURE_NAME/_index.md
        # Commit changes
        git commit -m "Generated consolidated content for feature: $FEATURE_NAME"
        git push
